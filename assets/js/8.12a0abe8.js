(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{174:function(a,t,e){"use strict";e.r(t);var r=e(0),n=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"时间格式化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#时间格式化","aria-hidden":"true"}},[a._v("#")]),a._v(" 时间格式化")]),a._v(" "),e("p",[a._v("界面展示的时间千变万化, 所以一个处理时间的函数，它的重要性就不言而喻了。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("export function formatDate (oldDate, fmt) {  \n  let date = new Date()  \n  if (typeof oldDate === 'string' || typeof oldDate === 'number') {    \n    date = new Date(+oldDate)  \n  } else {    \n    date = oldDate  \n  }  \nif (/(y+)/.test(fmt)) {    \n  fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length))  }  \n  let o = {    \n  'M+': date.getMonth() + 1,    \n  'd+': date.getDate(),    \n  'h+': date.getHours(),    \n  'm+': date.getMinutes(),    \n  's+': date.getSeconds()  }  \n  function padLeftZero (str) {    \n    return ('00' + str).substr(str.length)  \n  }  \n  for (let k in o) {    \n    if (new RegExp(`(${k})`).test(fmt)) {      \n      let str = o[k] + ''      \n      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str))    \n    }  \n  }  \n  return fmt\n}\n")])])]),e("p",[a._v("formatDate 接受俩个参数, oldDate 类型可以是 Date，String，Number。因为现在用时间戳传递时间真的是蛮多，也蛮方便的，而JS 是一门弱类型语言，所以我将 String 和 Number 类型的数据统一当做时间戳来处理。 fmt 是格式化的类型：yyyy-MM-dd hh:mm，其中的  yyyy | MM | dd | hh | mm 是分别匹配 年 | 月 | 日 | 时 | 分 的关键字。其中的连字符是可以随意替换的，只展示年月将其他关键字去掉即可。举几个例子：")]),a._v(" "),e("ul",[e("li",[a._v("yyyy年MM月dd -> 2019年09月7日")]),a._v(" "),e("li",[a._v("hh分mm秒 -> 16分53秒")])]),a._v(" "),e("h2",{attrs:{id:"以“天”为单位获取响应的时间戳"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#以“天”为单位获取响应的时间戳","aria-hidden":"true"}},[a._v("#")]),a._v(" 以“天”为单位获取响应的时间戳")]),a._v(" "),e("p",[a._v("通常都会获取三天前的时间，12 个以内的数据，24 小时以内的数据，因此我弄了一个以天为单位获取时间戳的函数")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("export function setDate(num) {  return Date.now() + num * 24 * 60 * 60 * 1000}\n")])])]),e("p",[a._v("时间为正可以获得未来的时间，时间为负可以获得过去时间。举个例子")]),a._v(" "),e("ul",[e("li",[a._v("12 个小时之前的时间 -> setDate(-.5)")]),a._v(" "),e("li",[a._v("24 个小时之前的时间 -> setDate(-1)")]),a._v(" "),e("li",[a._v("三天后的时间 -> setDate(3)")])]),a._v(" "),e("h2",{attrs:{id:"获取-url-中的参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取-url-中的参数","aria-hidden":"true"}},[a._v("#")]),a._v(" 获取 URL 中的参数")]),a._v(" "),e("p",[a._v("这个需求在三大框架的时代应用貌似不多了，不过面试中问的还是蛮多的，了解一下是好的.")]),a._v(" "),e("h3",{attrs:{id:"简单实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 简单实现")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var urlParams = new URLSearchParams('?post=1234&action=edit');\nconsole.log(urlParams.get('action')); // \"edit\"\n\n")])])]),e("p",[a._v("看了一下浏览器支持情况还是蛮好的，除了万恶的 ie")]),a._v(" "),e("h3",{attrs:{id:"复杂实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复杂实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 复杂实现")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function getUrlParams(param){\n  // 有赖于浏览器环境， window.location.search 是浏览器函数\n  // 意思是:设置或返回从问号 (?) 开始的 URL（查询部分）。       \n  var query = window.location.search.substring(1);       \n  var vars = query.split("&");       \n  for (var i=0;i<vars.length;i++) {               \n    var pair = vars[i].split("=");               \n    if(pair[0] == param){return pair[1];}       \n  }       \n  return(false);\n}\n')])])]),e("p",[a._v("举个例子： http://xuyuechao.top?a=3&b=5&c=8888")]),a._v(" "),e("ul",[e("li",[a._v("getUrlParams('a') -> 3")]),a._v(" "),e("li",[a._v("getUrlParams('b') -> 5")]),a._v(" "),e("li",[a._v("getUrlParams('c') -> 8888")])]),a._v(" "),e("h2",{attrs:{id:"手机端判断浏览器类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手机端判断浏览器类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 手机端判断浏览器类型")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("BrowserInfo = {      \n  isAndroid: Boolean(navigator.userAgent.match(/android/ig)),      \n  isIphone: Boolean(navigator.userAgent.match(/iphone|ipod/ig)),      \n  isIpad: Boolean(navigator.userAgent.match(/ipad/ig)),      \n  isWeixin: Boolean(navigator.userAgent.match(/MicroMessenger/ig)),      \n  isAli: Boolean(navigator.userAgent.match(/AlipayClient/ig)),\n  isPhone: Boolean(/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))\n}\n")])])]),e("p",[a._v("目前主要支持 安卓 & 苹果 & ipad & 微信 & 支付宝 & 是否是手机端。")]),a._v(" "),e("h2",{attrs:{id:"数组降维"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组降维","aria-hidden":"true"}},[a._v("#")]),a._v(" 数组降维")]),a._v(" "),e("h3",{attrs:{id:"二维数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二维数组","aria-hidden":"true"}},[a._v("#")]),a._v(" 二维数组")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let arr = [ [1], [2], [3] ]\narr = Array.prototype.concat.apply([], arr); // [1, 2, 3]\n")])])]),e("h3",{attrs:{id:"多维数组降维"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多维数组降维","aria-hidden":"true"}},[a._v("#")]),a._v(" 多维数组降维")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let arr = [1, 2, [3], [[4]]]\narr = arr.flat(3) // [1, 2, 3, 4]\n")])])]),e("p",[a._v("flat 有兼容性问题，手机端问题不大。浏览器端不兼容 edge。填 Infinity 可展开任意深度的数组")]),a._v(" "),e("h2",{attrs:{id:"深拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝","aria-hidden":"true"}},[a._v("#")]),a._v(" 深拷贝")]),a._v(" "),e("p",[a._v("使用变量 a 拷贝对象 b，改变 a 中的值 b 中的值也会跟着改变，这叫做浅拷贝。要想让 a 独立于 b 就需要深拷贝")]),a._v(" "),e("h3",{attrs:{id:"简易处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简易处理","aria-hidden":"true"}},[a._v("#")]),a._v(" 简易处理")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function deepClone() {\n    return JSON.parse(JSON.stringify(obj))\n}\n")])])]),e("p",[a._v("既然是简易处理就有他的不足，上面主要是用了 JSON 的序列化和反序列化。而 JSON 是不支持函数和 undefined 的因此碰到这些情况会缺失，但是已经能够满足大部分情况了")]),a._v(" "),e("h3",{attrs:{id:"复杂处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复杂处理","aria-hidden":"true"}},[a._v("#")]),a._v(" 复杂处理")]),a._v(" "),e("p",[a._v("复杂处理就需要采用递归的方式了")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function deepClone(obj) {  \n  function isClass(o) {    \n  if (o === null) return "Null";    \n  if (o === undefined) return "Undefined";    \n    return Object.prototype.toString.call(o).slice(8, -1);  \n  }  \n  var result;  \n  var oClass = isClass(obj);  \n  if (oClass === "Object") {    \n    result = {};  \n  } else if (oClass === "Array") {\n    result = [];  \n  } else {    \n    return obj;  \n  }  \n  for (var key in obj) {    \n    var copy = obj[key];    \n    if (isClass(copy) == "Object") {      \n      result[key] = arguments.callee(copy);//递归调用    \n    } else if (isClass(copy) == "Array") {      \n      result[key] = arguments.callee(copy);    \n    } else {      \n      result[key] = obj[key];    \n    }  \n  }  \n  return result;\n}\n')])])]),e("h2",{attrs:{id:"防抖-节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#防抖-节流","aria-hidden":"true"}},[a._v("#")]),a._v(" 防抖 & 节流")]),a._v(" "),e("p",[a._v("防抖和节流属于高阶技巧，业务中比较多见的场合也就是搜索内容改变提示信息。即使不加也也不一定能看出区别，但是加了新手维护代码可能会崇拜你哦。")]),a._v(" "),e("h3",{attrs:{id:"防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#防抖","aria-hidden":"true"}},[a._v("#")]),a._v(" 防抖")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function debounce(func, wait) {\n    let timeout;\n    return function () {\n        let context = this;\n        let args = arguments;\n\n        if (timeout) clearTimeout(timeout);\n        \n        timeout = setTimeout(() => {\n            func.apply(context, args)\n        }, wait);\n    }\n}\n")])])]),e("h3",{attrs:{id:"节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#节流","aria-hidden":"true"}},[a._v("#")]),a._v(" 节流")]),a._v(" "),e("p",[a._v("function throttle(func, wait) {\nlet previous = 0;\nreturn function() {\nlet now = Date.now();\nlet context = this;\nlet args = arguments;\nif (now - previous > wait) {\nfunc.apply(context, args);\nprevious = now;\n}\n}\n}")]),a._v(" "),e("h2",{attrs:{id:"获取数组极值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取数组极值","aria-hidden":"true"}},[a._v("#")]),a._v(" 获取数组极值")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function smallest(array){                           \n  return Math.min.apply(Math, array);             \n}                                                 \nfunction largest(array){                            \n  return Math.max.apply(Math, array);             \n}  \nsmallest([0, 1, 2.2, 3.3]); // 0\nlargest([0, 1, 2.2, 3.3]); // 3.3\n\n")])])]),e("p",[a._v("es6 的实现方式")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let list = [1, 2, 3, 4, 5]\nMath.max(...list) // 5\nMath.min(...list) // 1\n\n")])])]),e("h2",{attrs:{id:"判断小数是否相等"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断小数是否相等","aria-hidden":"true"}},[a._v("#")]),a._v(" 判断小数是否相等")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function epsEqu(x,y) {  \n  return Math.abs(x - y) < Math.pow(2, -52);\n}\n// 举例\n0.1 + 0.2 === 0.3 // false\nepsEqu(0.1 + 0.2, 0.3) // true\n")])])]),e("p",[a._v("Number.EPSILON ，Number.EPSILON === Math.pow(2, -52)因此上述方法也可以这么写")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function epsEqu(x,y) {  \n  return Math.abs(x - y) < Number.EPSILON;\n}\n")])])]),e("p",[a._v("用户输入的是十进制数字，计算机保存的是二进制数。所以计算结果会有偏差，所以我们不应该直接比较非整数，而是取其上限，把误差计算进去。这样一个上限称为 machine epsilon，双精度的标准 epsilon 值是 2^-53 （Math.pow(2, -53)）")]),a._v(" "),e("h2",{attrs:{id:"一些让-js-更优雅-易读的小技巧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一些让-js-更优雅-易读的小技巧","aria-hidden":"true"}},[a._v("#")]),a._v(" 一些让 JS 更优雅 / 易读的小技巧")]),a._v(" "),e("p",[a._v("对于工程师来说，代码是写一遍、修改很多遍、阅读更多遍的重要产出，可读性至关重要，所以高可读代码的重要性不言而喻。")]),a._v(" "),e("h3",{attrs:{id:"用对象代替-switch-if"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用对象代替-switch-if","aria-hidden":"true"}},[a._v("#")]),a._v(" 用对象代替 switch / if")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("公共内容:\nlet a = 'VIP'\n\n场景 1\nif (a === 'VIP') {\n  return 1\n} else if (a === 'SVIP') {\n  return 2\n}\n\n场景 2\nswitch(a) { // 感谢 红山老六 的评论指出这部分代码的 bug。现已改正\n  case 'VIP':\n    return 1\n  case 'SVIP':\n    return 2\n}\n\n场景 3\nlet obj = {\n  VIP: 1,\n  SVIP: 2\n}\n")])])]),e("h3",{attrs:{id:"和-的妙用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和-的妙用","aria-hidden":"true"}},[a._v("#")]),a._v(" || 和 && 的妙用")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 场景 1\nfunction b(a) {\n  if (a) {\n    return a\n  } else {\n    return ''\n  }\n}\n// 场景 2\nfunction b(a) {\n  return a || ''\n}\n")])])]),e("p",[a._v("上面是 || 的用法，也叫做短路处理。常见于 if 条件中，但是他其实也可以直接用于语句中。当第一个参数为 true 就会取第一个参数的值，当第一个参数不为 true 就会取第二个参数的值。&& 正好与 || 相反。第一个参数 为 true 会取第二个参数的值")])])}],!1,null,null,null);t.default=n.exports}}]);