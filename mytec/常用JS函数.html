<!DOCTYPE html>
<html lang="cn-Zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>WinePlus服务器的架设</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.5949d6f5.css" as="style"><link rel="preload" href="/assets/js/app.d8c8cb07.js" as="script"><link rel="preload" href="/assets/js/8.12a0abe8.js" as="script"><link rel="prefetch" href="/assets/js/10.a876fc82.js"><link rel="prefetch" href="/assets/js/2.d139c70a.js"><link rel="prefetch" href="/assets/js/3.e9f05c4e.js"><link rel="prefetch" href="/assets/js/4.a0f8c751.js"><link rel="prefetch" href="/assets/js/5.11875d57.js"><link rel="prefetch" href="/assets/js/6.6be5c327.js"><link rel="prefetch" href="/assets/js/7.625db83a.js"><link rel="prefetch" href="/assets/js/9.bebdc638.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5949d6f5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>WinePlus服务器的架设</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#时间格式化" class="sidebar-link">时间格式化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#以“天”为单位获取响应的时间戳" class="sidebar-link">以“天”为单位获取响应的时间戳</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#获取-url-中的参数" class="sidebar-link">获取 URL 中的参数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#简单实现" class="sidebar-link">简单实现</a></li><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#复杂实现" class="sidebar-link">复杂实现</a></li></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#手机端判断浏览器类型" class="sidebar-link">手机端判断浏览器类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#数组降维" class="sidebar-link">数组降维</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#二维数组" class="sidebar-link">二维数组</a></li><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#多维数组降维" class="sidebar-link">多维数组降维</a></li></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#深拷贝" class="sidebar-link">深拷贝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#简易处理" class="sidebar-link">简易处理</a></li><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#复杂处理" class="sidebar-link">复杂处理</a></li></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#防抖-节流" class="sidebar-link">防抖 &amp; 节流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#防抖" class="sidebar-link">防抖</a></li><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#节流" class="sidebar-link">节流</a></li></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#获取数组极值" class="sidebar-link">获取数组极值</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#判断小数是否相等" class="sidebar-link">判断小数是否相等</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#一些让-js-更优雅-易读的小技巧" class="sidebar-link">一些让 JS 更优雅 / 易读的小技巧</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#用对象代替-switch-if" class="sidebar-link">用对象代替 switch / if</a></li><li class="sidebar-sub-header"><a href="/mytec/%E5%B8%B8%E7%94%A8JS%E5%87%BD%E6%95%B0.html#和-的妙用" class="sidebar-link">|| 和 &amp;&amp; 的妙用</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="时间格式化"><a href="#时间格式化" aria-hidden="true" class="header-anchor">#</a> 时间格式化</h2> <p>界面展示的时间千变万化, 所以一个处理时间的函数，它的重要性就不言而喻了。</p> <div class="language- extra-class"><pre class="language-text"><code>export function formatDate (oldDate, fmt) {  
  let date = new Date()  
  if (typeof oldDate === 'string' || typeof oldDate === 'number') {    
    date = new Date(+oldDate)  
  } else {    
    date = oldDate  
  }  
if (/(y+)/.test(fmt)) {    
  fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length))  }  
  let o = {    
  'M+': date.getMonth() + 1,    
  'd+': date.getDate(),    
  'h+': date.getHours(),    
  'm+': date.getMinutes(),    
  's+': date.getSeconds()  }  
  function padLeftZero (str) {    
    return ('00' + str).substr(str.length)  
  }  
  for (let k in o) {    
    if (new RegExp(`(${k})`).test(fmt)) {      
      let str = o[k] + ''      
      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str))    
    }  
  }  
  return fmt
}
</code></pre></div><p>formatDate 接受俩个参数, oldDate 类型可以是 Date，String，Number。因为现在用时间戳传递时间真的是蛮多，也蛮方便的，而JS 是一门弱类型语言，所以我将 String 和 Number 类型的数据统一当做时间戳来处理。 fmt 是格式化的类型：yyyy-MM-dd hh:mm，其中的  yyyy | MM | dd | hh | mm 是分别匹配 年 | 月 | 日 | 时 | 分 的关键字。其中的连字符是可以随意替换的，只展示年月将其他关键字去掉即可。举几个例子：</p> <ul><li>yyyy年MM月dd -&gt; 2019年09月7日</li> <li>hh分mm秒 -&gt; 16分53秒</li></ul> <h2 id="以“天”为单位获取响应的时间戳"><a href="#以“天”为单位获取响应的时间戳" aria-hidden="true" class="header-anchor">#</a> 以“天”为单位获取响应的时间戳</h2> <p>通常都会获取三天前的时间，12 个以内的数据，24 小时以内的数据，因此我弄了一个以天为单位获取时间戳的函数</p> <div class="language- extra-class"><pre class="language-text"><code>export function setDate(num) {  return Date.now() + num * 24 * 60 * 60 * 1000}
</code></pre></div><p>时间为正可以获得未来的时间，时间为负可以获得过去时间。举个例子</p> <ul><li>12 个小时之前的时间 -&gt; setDate(-.5)</li> <li>24 个小时之前的时间 -&gt; setDate(-1)</li> <li>三天后的时间 -&gt; setDate(3)</li></ul> <h2 id="获取-url-中的参数"><a href="#获取-url-中的参数" aria-hidden="true" class="header-anchor">#</a> 获取 URL 中的参数</h2> <p>这个需求在三大框架的时代应用貌似不多了，不过面试中问的还是蛮多的，了解一下是好的.</p> <h3 id="简单实现"><a href="#简单实现" aria-hidden="true" class="header-anchor">#</a> 简单实现</h3> <div class="language- extra-class"><pre class="language-text"><code>var urlParams = new URLSearchParams('?post=1234&amp;action=edit');
console.log(urlParams.get('action')); // &quot;edit&quot;

</code></pre></div><p>看了一下浏览器支持情况还是蛮好的，除了万恶的 ie</p> <h3 id="复杂实现"><a href="#复杂实现" aria-hidden="true" class="header-anchor">#</a> 复杂实现</h3> <div class="language- extra-class"><pre class="language-text"><code>function getUrlParams(param){
  // 有赖于浏览器环境， window.location.search 是浏览器函数
  // 意思是:设置或返回从问号 (?) 开始的 URL（查询部分）。       
  var query = window.location.search.substring(1);       
  var vars = query.split(&quot;&amp;&quot;);       
  for (var i=0;i&lt;vars.length;i++) {               
    var pair = vars[i].split(&quot;=&quot;);               
    if(pair[0] == param){return pair[1];}       
  }       
  return(false);
}
</code></pre></div><p>举个例子： http://xuyuechao.top?a=3&amp;b=5&amp;c=8888</p> <ul><li>getUrlParams('a') -&gt; 3</li> <li>getUrlParams('b') -&gt; 5</li> <li>getUrlParams('c') -&gt; 8888</li></ul> <h2 id="手机端判断浏览器类型"><a href="#手机端判断浏览器类型" aria-hidden="true" class="header-anchor">#</a> 手机端判断浏览器类型</h2> <div class="language- extra-class"><pre class="language-text"><code>BrowserInfo = {      
  isAndroid: Boolean(navigator.userAgent.match(/android/ig)),      
  isIphone: Boolean(navigator.userAgent.match(/iphone|ipod/ig)),      
  isIpad: Boolean(navigator.userAgent.match(/ipad/ig)),      
  isWeixin: Boolean(navigator.userAgent.match(/MicroMessenger/ig)),      
  isAli: Boolean(navigator.userAgent.match(/AlipayClient/ig)),
  isPhone: Boolean(/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
}
</code></pre></div><p>目前主要支持 安卓 &amp; 苹果 &amp; ipad &amp; 微信 &amp; 支付宝 &amp; 是否是手机端。</p> <h2 id="数组降维"><a href="#数组降维" aria-hidden="true" class="header-anchor">#</a> 数组降维</h2> <h3 id="二维数组"><a href="#二维数组" aria-hidden="true" class="header-anchor">#</a> 二维数组</h3> <div class="language- extra-class"><pre class="language-text"><code>let arr = [ [1], [2], [3] ]
arr = Array.prototype.concat.apply([], arr); // [1, 2, 3]
</code></pre></div><h3 id="多维数组降维"><a href="#多维数组降维" aria-hidden="true" class="header-anchor">#</a> 多维数组降维</h3> <div class="language- extra-class"><pre class="language-text"><code>let arr = [1, 2, [3], [[4]]]
arr = arr.flat(3) // [1, 2, 3, 4]
</code></pre></div><p>flat 有兼容性问题，手机端问题不大。浏览器端不兼容 edge。填 Infinity 可展开任意深度的数组</p> <h2 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h2> <p>使用变量 a 拷贝对象 b，改变 a 中的值 b 中的值也会跟着改变，这叫做浅拷贝。要想让 a 独立于 b 就需要深拷贝</p> <h3 id="简易处理"><a href="#简易处理" aria-hidden="true" class="header-anchor">#</a> 简易处理</h3> <div class="language- extra-class"><pre class="language-text"><code>function deepClone() {
    return JSON.parse(JSON.stringify(obj))
}
</code></pre></div><p>既然是简易处理就有他的不足，上面主要是用了 JSON 的序列化和反序列化。而 JSON 是不支持函数和 undefined 的因此碰到这些情况会缺失，但是已经能够满足大部分情况了</p> <h3 id="复杂处理"><a href="#复杂处理" aria-hidden="true" class="header-anchor">#</a> 复杂处理</h3> <p>复杂处理就需要采用递归的方式了</p> <div class="language- extra-class"><pre class="language-text"><code>function deepClone(obj) {  
  function isClass(o) {    
  if (o === null) return &quot;Null&quot;;    
  if (o === undefined) return &quot;Undefined&quot;;    
    return Object.prototype.toString.call(o).slice(8, -1);  
  }  
  var result;  
  var oClass = isClass(obj);  
  if (oClass === &quot;Object&quot;) {    
    result = {};  
  } else if (oClass === &quot;Array&quot;) {
    result = [];  
  } else {    
    return obj;  
  }  
  for (var key in obj) {    
    var copy = obj[key];    
    if (isClass(copy) == &quot;Object&quot;) {      
      result[key] = arguments.callee(copy);//递归调用    
    } else if (isClass(copy) == &quot;Array&quot;) {      
      result[key] = arguments.callee(copy);    
    } else {      
      result[key] = obj[key];    
    }  
  }  
  return result;
}
</code></pre></div><h2 id="防抖-节流"><a href="#防抖-节流" aria-hidden="true" class="header-anchor">#</a> 防抖 &amp; 节流</h2> <p>防抖和节流属于高阶技巧，业务中比较多见的场合也就是搜索内容改变提示信息。即使不加也也不一定能看出区别，但是加了新手维护代码可能会崇拜你哦。</p> <h3 id="防抖"><a href="#防抖" aria-hidden="true" class="header-anchor">#</a> 防抖</h3> <div class="language- extra-class"><pre class="language-text"><code>function debounce(func, wait) {
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        
        timeout = setTimeout(() =&gt; {
            func.apply(context, args)
        }, wait);
    }
}
</code></pre></div><h3 id="节流"><a href="#节流" aria-hidden="true" class="header-anchor">#</a> 节流</h3> <p>function throttle(func, wait) {
let previous = 0;
return function() {
let now = Date.now();
let context = this;
let args = arguments;
if (now - previous &gt; wait) {
func.apply(context, args);
previous = now;
}
}
}</p> <h2 id="获取数组极值"><a href="#获取数组极值" aria-hidden="true" class="header-anchor">#</a> 获取数组极值</h2> <div class="language- extra-class"><pre class="language-text"><code>function smallest(array){                           
  return Math.min.apply(Math, array);             
}                                                 
function largest(array){                            
  return Math.max.apply(Math, array);             
}  
smallest([0, 1, 2.2, 3.3]); // 0
largest([0, 1, 2.2, 3.3]); // 3.3

</code></pre></div><p>es6 的实现方式</p> <div class="language- extra-class"><pre class="language-text"><code>let list = [1, 2, 3, 4, 5]
Math.max(...list) // 5
Math.min(...list) // 1

</code></pre></div><h2 id="判断小数是否相等"><a href="#判断小数是否相等" aria-hidden="true" class="header-anchor">#</a> 判断小数是否相等</h2> <div class="language- extra-class"><pre class="language-text"><code>function epsEqu(x,y) {  
  return Math.abs(x - y) &lt; Math.pow(2, -52);
}
// 举例
0.1 + 0.2 === 0.3 // false
epsEqu(0.1 + 0.2, 0.3) // true
</code></pre></div><p>Number.EPSILON ，Number.EPSILON === Math.pow(2, -52)因此上述方法也可以这么写</p> <div class="language- extra-class"><pre class="language-text"><code>function epsEqu(x,y) {  
  return Math.abs(x - y) &lt; Number.EPSILON;
}
</code></pre></div><p>用户输入的是十进制数字，计算机保存的是二进制数。所以计算结果会有偏差，所以我们不应该直接比较非整数，而是取其上限，把误差计算进去。这样一个上限称为 machine epsilon，双精度的标准 epsilon 值是 2^-53 （Math.pow(2, -53)）</p> <h2 id="一些让-js-更优雅-易读的小技巧"><a href="#一些让-js-更优雅-易读的小技巧" aria-hidden="true" class="header-anchor">#</a> 一些让 JS 更优雅 / 易读的小技巧</h2> <p>对于工程师来说，代码是写一遍、修改很多遍、阅读更多遍的重要产出，可读性至关重要，所以高可读代码的重要性不言而喻。</p> <h3 id="用对象代替-switch-if"><a href="#用对象代替-switch-if" aria-hidden="true" class="header-anchor">#</a> 用对象代替 switch / if</h3> <div class="language- extra-class"><pre class="language-text"><code>公共内容:
let a = 'VIP'

场景 1
if (a === 'VIP') {
  return 1
} else if (a === 'SVIP') {
  return 2
}

场景 2
switch(a) { // 感谢 红山老六 的评论指出这部分代码的 bug。现已改正
  case 'VIP':
    return 1
  case 'SVIP':
    return 2
}

场景 3
let obj = {
  VIP: 1,
  SVIP: 2
}
</code></pre></div><h3 id="和-的妙用"><a href="#和-的妙用" aria-hidden="true" class="header-anchor">#</a> || 和 &amp;&amp; 的妙用</h3> <div class="language- extra-class"><pre class="language-text"><code>// 场景 1
function b(a) {
  if (a) {
    return a
  } else {
    return ''
  }
}
// 场景 2
function b(a) {
  return a || ''
}
</code></pre></div><p>上面是 || 的用法，也叫做短路处理。常见于 if 条件中，但是他其实也可以直接用于语句中。当第一个参数为 true 就会取第一个参数的值，当第一个参数不为 true 就会取第二个参数的值。&amp;&amp; 正好与 || 相反。第一个参数 为 true 会取第二个参数的值</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.d8c8cb07.js" defer></script><script src="/assets/js/8.12a0abe8.js" defer></script>
  </body>
</html>
